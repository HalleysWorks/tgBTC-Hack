#include "./stdlib.fc";

;; ---------- Constants (compile-time) ----------
const OP_MINT              = 1;          ;; mint(to, amount)
const OP_INTERNAL_TRANSFER = 0x178d4519; ;; internal jetton transfer
const OP_BURN              = 0x595f07bc; ;; burn

;; ---------- Storage layout ----------
;; 0 uint64 totalSupply
;; 1 addr   admin
;; 2 cell   walletCode

;; Load state from storage
(int, slice, cell) load_state() {
    slice ds = get_data().begin_parse();
    int   sup  = ds~load_uint(64);
    slice adm  = ds~load_msg_addr();
    cell  wc   = ds~load_ref();
    return (sup, adm, wc);
}

;; Save state to storage
() save_state(int sup, slice adm, cell wc) impure {
    builder b = begin_cell()
        .store_uint(sup, 64)
        .store_slice(adm)
        .store_ref(wc);
    set_data(b.end_cell());
}

() recv_internal(int my_balance, int msg_value, cell in_full, slice in_body) impure {
    ;; If no body, ignore
    if (in_body.slice_empty?()) {
        return ();
    }

    ;; Parse header to get sender
    slice hdr = in_full.begin_parse();
    hdr~load_uint(4);              ;; skip flags
    slice sender = hdr~load_msg_addr();

    ;; Parse operation code
    int op = in_body~load_uint(32);

    ;; Handle mint
    if (op == OP_MINT) {
        slice to     = in_body~load_msg_addr();
        int   amount = in_body~load_uint(64);

        var (sup, adm, wc) = load_state();
        throw_unless(401, equal_slice_bits(sender, adm));  ;; only admin

        sup = sup + amount;
        save_state(sup, adm, wc);
        return ();
    }

    ;; Handle internal transfer (used by pools)
    if (op == OP_INTERNAL_TRANSFER) {
        slice to     = in_body~load_msg_addr();
        int   amount = in_body~load_uint(64);

        var (sup, adm, wc) = load_state();
        ;; For demo: do not update totalSupply
        ;; In full implementation: update balances in wallets
        return ();
    }

    ;; Ignore burn or other ops in demo
    return ();
}

;; Returns (totalSupply, 0, admin, empty code, empty data)
(int, int, slice, cell, cell) get_jetton_data() method_id {
    var (sup, adm, wc) = load_state();
    return (sup, 0, adm, begin_cell().end_cell(), wc);
}
